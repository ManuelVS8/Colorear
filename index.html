<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generador de Plantillas - CEIP Manuel Siurot</title>
    <style>
        :root {
            --bg-start: #1a3a5f;
            --bg-end: #0d2340;
            --panel-bg: #FFFFFF;
            --primary-btn: #f59e42;
            --interactive-blue: #4A90E2; /* Nuevo color para controles interactivos */
            --text-color: #333333;
            --accent-text: #FFFFFF;
            --border-radius: 12px;
            --shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(to right, var(--bg-start), var(--bg-end));
            color: var(--text-color);
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        header {
            width: 100%;
            background-color: rgba(255, 255, 255, 0.1);
            padding: 15px 20px;
            text-align: center;
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .branding {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .branding img {
            height: 60px;
            width: auto;
            border-radius: 50%;
            background-color: white;
            padding: 5px;
        }

        .branding h1 {
            color: var(--accent-text);
            font-size: 2.5em;
            margin: 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .container {
            max-width: 1000px;
            width: 90%;
            background-color: var(--panel-bg);
            margin: 30px auto;
            padding: 30px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
        }

        .app-title {
            text-align: center;
            color: var(--bg-start);
            margin-bottom: 10px;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
            padding: 20px;
            background-color: #f4f7f9;
            border-radius: var(--border-radius);
            border: 1px solid #e0e0e0;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 10px; /* Espacio entre slider y botones */
        }

        label {
            margin-bottom: 5px;
            font-weight: 600;
            color: var(--bg-start);
        }

        input[type="file"] {
            display: none;
        }

        .file-upload-label {
            display: block;
            padding: 12px 15px;
            background-color: var(--primary-btn);
            color: var(--accent-text);
            text-align: center;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            font-weight: bold;
        }

        .file-upload-label:hover {
            background-color: #e68a00;
            transform: translateY(-2px);
        }

        /* --- Estilos para la Barra Deslizante --- */
        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
            cursor: pointer;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--interactive-blue);
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: #357ABD;
            transform: scale(1.2);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--interactive-blue);
            cursor: pointer;
            border: none;
            transition: background-color 0.3s, transform 0.2s;
        }

        input[type="range"]::-moz-range-thumb:hover {
            background: #357ABD;
            transform: scale(1.2);
        }

        .range-value {
            text-align: center;
            font-size: 1.2em;
            font-weight: bold;
            color: var(--interactive-blue);
        }

        /* --- Estilos para los Botones T√°ctiles --- */
        .stepper-control {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }

        .stepper-button {
            background-color: var(--interactive-blue);
            color: var(--accent-text);
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.3s, transform 0.2s;
        }

        .stepper-button:hover {
            background-color: #357ABD;
            transform: scale(1.1);
        }

        .stepper-button:active {
            transform: scale(0.95);
        }

        button {
            padding: 12px 20px;
            font-size: 1em;
            font-weight: bold;
            color: var(--accent-text);
            background-color: var(--primary-btn);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
        }

        button:hover {
            background-color: #e68a00;
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .output-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .canvas-container {
            text-align: center;
        }

        .canvas-container h3 {
            margin-bottom: 10px;
            color: var(--bg-start);
        }

        canvas {
            max-width: 100%;
            height: auto;
            border: 2px solid var(--bg-start);
            border-radius: var(--border-radius);
            background-color: #fff;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        #palette-container {
            margin-top: 20px;
            text-align: center;
        }

        #palette {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }

        .color-swatch {
            display: flex;
            flex-direction: column;
            align-items: center;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 5px;
            background-color: #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .color-box {
            width: 40px;
            height: 40px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        .color-number {
            margin-top: 5px;
            font-weight: bold;
            color: #333;
        }
        
        .message {
            padding: 15px;
            margin: 20px 0;
            border-radius: 8px;
            text-align: center;
            font-weight: 500;
        }

        .message.info { background-color: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
        .message.success { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .message.error { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }

        @media (max-width: 768px) {
            .branding h1 { font-size: 1.8em; }
            .branding img { height: 50px; }
            .output-area { grid-template-columns: 1fr; }
            .controls { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>

    <header>
        <div class="branding">
            <img src="https://raw.githubusercontent.com/ManuelVS8/Efectos_audio/1e2a36cdd1f8bedcb578a30f5ec5cc8f21c287fe/Siurot.png" alt="Logo del CEIP Manuel Siurot">
            <h1>CEIP Manuel Siurot</h1>
        </div>
    </header>

    <main class="container">
        <h2 class="app-title">üñçÔ∏è Generador de Plantillas para Colorear</h2>
        <p class="subtitle">Crea gu√≠as imprimibles ajustando el tama√±o de la cuadr√≠cula (de 10x10 a 40x40).</p>
        
        <div id="message-area"></div>

        <section class="controls">
            <div class="control-group">
                <label for="imageUpload" class="file-upload-label">
                    üìÅ Sube tu Imagen
                </label>
                <input type="file" id="imageUpload" accept="image/*">
            </div>
            <div class="control-group">
                <label for="colorCount">N√∫mero de Colores</label>
                <input type="range" id="colorCount" min="2" max="20" value="8">
                <div class="range-value" id="colorCountValue">8</div>
                <div class="stepper-control" data-min="2" data-max="20">
                    <button class="stepper-button decrement" data-target="colorCount">-</button>
                    <button class="stepper-button increment" data-target="colorCount">+</button>
                </div>
            </div>
            <div class="control-group">
                <label for="gridSize">Tama√±o de la Cuadr√≠cula</label>
                <input type="range" id="gridSize" min="10" max="40" value="20">
                <div class="range-value" id="gridSizeValue">20 x 20</div>
                <div class="stepper-control" data-min="10" data-max="40">
                    <button class="stepper-button decrement" data-target="gridSize">-</button>
                    <button class="stepper-button increment" data-target="gridSize">+</button>
                </div>
            </div>
            <div class="control-group">
                <label>&nbsp;</label>
                <button id="generateBtn" disabled>üöÄ Generar Plantilla</button>
            </div>
            <div class="control-group">
                <label>&nbsp;</label>
                <button id="downloadBtn" disabled>üíæ Descargar Plantilla (HQ)</button>
            </div>
        </section>

        <section class="output-area">
            <div class="canvas-container">
                <h3>Imagen Original</h3>
                <canvas id="originalCanvas"></canvas>
            </div>
            <div class="canvas-container">
                <h3>Plantilla para Colorear</h3>
                <canvas id="resultCanvas"></canvas>
            </div>
        </section>

        <div id="palette-container">
            <h3>C√≥digo de Colores</h3>
            <div id="palette"></div>
        </div>
    </main>

<script>
// --- Web Worker como un Blob para mantener todo en un solo archivo ---
const workerCode = `
    self.onmessage = function(e) {
        const { imageData, k } = e.data;
        const palette = kMeansImproved(imageData, k);
        self.postMessage({ type: 'palette', palette });
    };

    function kMeansImproved(data, k) {
        const points = [];
        for (let i = 0; i < data.length; i += 4) {
            points.push([data[i], data[i + 1], data[i + 2]]);
        }
        let centroids = kMeansPlusPlus(points, k);
        for (let iter = 0; iter < 20; iter++) {
            const clusters = Array.from({ length: k }, () => []);
            for (const point of points) {
                let minDist = Infinity; let closestCentroidIndex = 0;
                centroids.forEach((centroid, index) => {
                    const dist = euclideanDistance(point, centroid);
                    if (dist < minDist) { minDist = dist; closestCentroidIndex = index; }
                });
                clusters[closestCentroidIndex].push(point);
            }
            let newCentroids = [];
            for (let i = 0; i < k; i++) {
                const cluster = clusters[i];
                if (cluster.length > 0) {
                    const mean = [0, 0, 0];
                    for (const point of cluster) { mean[0] += point[0]; mean[1] += point[1]; mean[2] += point[2]; }
                    newCentroids.push([ Math.round(mean[0] / cluster.length), Math.round(mean[1] / cluster.length), Math.round(mean[2] / cluster.length) ]);
                } else {
                    newCentroids.push(points[Math.floor(Math.random() * points.length)]);
                }
            }
            centroids = newCentroids;
        }
        return centroids.map(c => ({ r: c[0], g: c[1], b: c[2] }));
    }

    function kMeansPlusPlus(points, k) {
        if (k <= 0 || points.length === 0) return [];
        if (k === 1) return [points[Math.floor(Math.random() * points.length)]];
        const centroids = [];
        centroids.push(points[Math.floor(Math.random() * points.length)]);
        for (let i = 1; i < k; i++) {
            const distances = []; let sumOfDistances = 0;
            for (const point of points) {
                let minDist = Infinity;
                for (const centroid of centroids) {
                    const dist = euclideanDistance(point, centroid);
                    if (dist < minDist) { minDist = dist; }
                }
                distances.push(minDist * minDist);
                sumOfDistances += distances[distances.length - 1];
            }
            let random = Math.random() * sumOfDistances;
            for (let j = 0; j < points.length; j++) {
                random -= distances[j];
                if (random <= 0) { centroids.push(points[j]); break; }
            }
        }
        return centroids;
    }

    function euclideanDistance(p1, p2) {
        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2) + Math.pow(p1[2] - p2[2], 2));
    }
`;
const blob = new Blob([workerCode], { type: 'application/javascript' });
const worker = new Worker(URL.createObjectURL(blob));

document.addEventListener('DOMContentLoaded', () => {
    // --- Sonido Interactivo ---
    const tapSound = new Audio('https://raw.githubusercontent.com/ManuelVS8/Efectos_audio/37b3eb2da9c15c04dfb71dfe1be60f088ea3cdfc/Tap.mp3');
    tapSound.preload = 'auto';

    function playTapSound() {
        tapSound.currentTime = 0;
        tapSound.play().catch(error => console.error("Error al reproducir el sonido:", error));
    }

    const interactiveElements = document.querySelectorAll('button, .file-upload-label, input[type="range"]');
    interactiveElements.forEach(el => {
        el.addEventListener('click', playTapSound);
        el.addEventListener('input', playTapSound);
    });

    // --- Elementos del DOM ---
    const imageUpload = document.getElementById('imageUpload');
    const originalCanvas = document.getElementById('originalCanvas');
    const resultCanvas = document.getElementById('resultCanvas');
    const generateBtn = document.getElementById('generateBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const colorCountSlider = document.getElementById('colorCount');
    const gridSizeSlider = document.getElementById('gridSize');
    const colorCountValue = document.getElementById('colorCountValue');
    const gridSizeValue = document.getElementById('gridSizeValue');
    const paletteDiv = document.getElementById('palette');
    const messageArea = document.getElementById('message-area');

    const originalCtx = originalCanvas.getContext('2d');
    const resultCtx = resultCanvas.getContext('2d');
    
    let originalImageData = null;
    let currentPalette = [];
    let debounceTimer;

    // --- Estado de los controles ---
    let colorCount = 8;
    let gridSize = 20;

    // --- Event Listeners ---
    imageUpload.addEventListener('change', handleImageUpload);
    generateBtn.addEventListener('click', generateColoringTemplate);
    downloadBtn.addEventListener('click', downloadResult);

    // --- L√≥gica de los controles h√≠bridos ---
    function updateControl(controlName, value) {
        if (controlName === 'colorCount') {
            colorCount = value;
            colorCountSlider.value = value;
            colorCountValue.textContent = value;
        } else if (controlName === 'gridSize') {
            gridSize = value;
            gridSizeSlider.value = value;
            gridSizeValue.textContent = `${value} x ${value}`;
        }
        playTapSound();
    }

    colorCountSlider.addEventListener('input', (e) => updateControl('colorCount', parseInt(e.target.value)));
    gridSizeSlider.addEventListener('input', (e) => updateControl('gridSize', parseInt(e.target.value)));

    document.querySelectorAll('.stepper-button').forEach(btn => {
        btn.addEventListener('click', (e) => {
            const targetControl = e.target.dataset.target;
            const delta = e.target.classList.contains('increment') ? 1 : -1;
            let currentValue = (targetControl === 'colorCount') ? colorCount : gridSize;
            const min = parseInt(e.target.closest('.stepper-control').dataset.min);
            const max = parseInt(e.target.closest('.stepper-control').dataset.max);
            const newValue = Math.max(min, Math.min(max, currentValue + delta));
            updateControl(targetControl, newValue);

            if (originalImageData && targetControl === 'colorCount') {
                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(() => requestPaletteUpdate(), 300);
            }
        });
    });


    // --- Comunicaci√≥n con el Web Worker ---
    worker.onmessage = function(e) {
        const { type, palette } = e.data;
        if (type === 'palette') {
            currentPalette = palette;
            displayPalette(palette);
            if (generateBtn.disabled) {
                generateBtn.disabled = false;
                downloadBtn.disabled = false;
                showMessage('Paleta actualizada. ¬°Ya puedes generar o descargar la plantilla!', 'success');
            }
        }
    };

    // --- Funciones de UI ---
    function showMessage(text, type = 'info') {
        messageArea.innerHTML = `<div class="message ${type}">${text}</div>`;
        setTimeout(() => { messageArea.innerHTML = ''; }, 4000);
    }

    // --- L√≥gica Principal ---
    function handleImageUpload(e) {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
            const img = new Image();
            img.onload = () => {
                originalCanvas.width = img.width;
                originalCanvas.height = img.height;
                originalCtx.drawImage(img, 0, 0);
                originalImageData = originalCtx.getImageData(0, 0, img.width, img.height);
                
                paletteDiv.innerHTML = '';
                requestPaletteUpdate();
                showMessage('Imagen cargada. Generando paleta de colores...', 'info');
            };
            img.src = event.target.result;
        };
        reader.readAsDataURL(file);
    }

    function requestPaletteUpdate() {
        if (!originalImageData) return;
        worker.postMessage({ imageData: originalImageData.data, k: colorCount });
    }

    function generateColoringTemplate() {
        if (!originalImageData || currentPalette.length === 0) {
            showMessage('Por favor, sube una imagen y espera a que se genere la paleta.', 'error');
            return;
        }
        
        showMessage('Generando previsualizaci√≥n...', 'info');
        drawTemplate(originalImageData, currentPalette, gridSize, true);
        showMessage(`¬°Previsualizaci√≥n ${gridSize}x${gridSize} generada!`, 'success');
    }

    function downloadResult() {
        if (!originalImageData || currentPalette.length === 0) {
            showMessage('Por favor, genera una plantilla primero.', 'error');
            return;
        }
        
        showMessage('Preparando plantilla para imprimir...', 'info');
        drawTemplate(originalImageData, currentPalette, gridSize, false);

        const link = document.createElement('a');
        link.download = `plantilla-ceip-siurot-${gridSize}x${gridSize}-HQ.png`;
        link.href = resultCanvas.toDataURL();
        link.click();

        drawTemplate(originalImageData, currentPalette, gridSize, true);
        showMessage('¬°Plantilla descargada con √©xito!', 'success');
    }

    // --- Algoritmos de Procesamiento de Imagen ---
    function drawTemplate(imageData, palette, gridSize, isPreview = true) {
        const { width, height, data } = imageData;
        const scaleFactor = 2;
        const gridCols = gridSize; const gridRows = gridSize;
        const cellWidth = (width / gridCols) * scaleFactor; const cellHeight = (height / gridRows) * scaleFactor;

        const palettePadding = 20 * scaleFactor;
        const swatchSize = 30 * scaleFactor;
        const swatchGap = 15 * scaleFactor;
        const textSpace = 40 * scaleFactor;
        const paletteTitleFontSize = 24 * scaleFactor;
        const paletteTextFontSize = 16 * scaleFactor;
        
        const itemWidth = swatchSize + swatchGap + textSpace;
        const maxColorsPerRow = Math.floor((width * scaleFactor - 2 * palettePadding) / itemWidth);
        const paletteRows = Math.ceil(palette.length / maxColorsPerRow);
        const paletteAreaHeight = (palettePadding * 2 + paletteTitleFontSize + 10 + paletteRows * (swatchSize + paletteTextFontSize + swatchGap));
        
        resultCanvas.width = width * scaleFactor;
        resultCanvas.height = (height + paletteAreaHeight / scaleFactor) * scaleFactor;

        resultCtx.fillStyle = 'white';
        resultCtx.fillRect(0, 0, resultCanvas.width, resultCanvas.height);
        resultCtx.strokeStyle = 'black';
        resultCtx.lineWidth = 1 * scaleFactor;
        resultCtx.textAlign = 'center';
        resultCtx.textBaseline = 'middle';

        for (let row = 0; row < gridRows; row++) {
            for (let col = 0; col < gridCols; col++) {
                const x = col * cellWidth; const y = row * cellHeight;
                const sampleX = Math.floor(x / scaleFactor + (cellWidth / scaleFactor) / 2); 
                const sampleY = Math.floor(y / scaleFactor + (cellHeight / scaleFactor) / 2);
                const i = (sampleY * width + sampleX) * 4;
                
                const alpha = data[i + 3];
                let pixelColor;
                if (alpha < 128) { pixelColor = { r: 255, g: 255, b: 255 }; }
                else { pixelColor = { r: data[i], g: data[i + 1], b: data[i + 2] }; }

                let closestColorIndex = 0; let minDist = Infinity;
                palette.forEach((color, index) => {
                    const dist = euclideanDistance([pixelColor.r, pixelColor.g, pixelColor.b], [color.r, color.g, color.b]);
                    if (dist < minDist) { minDist = dist; closestColorIndex = index; }
                });
                
                if (isPreview) {
                    resultCtx.fillStyle = `rgb(${palette[closestColorIndex].r}, ${palette[closestColorIndex].g}, ${palette[closestColorIndex].b})`;
                    resultCtx.fillRect(x, y, cellWidth, cellHeight);
                }
                resultCtx.strokeRect(x, y, cellWidth, cellHeight);
                
                const number = closestColorIndex + 1;
                const fontSize = Math.max(8 * scaleFactor, Math.min(cellWidth, cellHeight) / 2.5);
                resultCtx.font = `bold ${fontSize}px Arial`;
                
                if (isPreview) {
                    const luma = 0.299 * palette[closestColorIndex].r + 0.587 * palette[closestColorIndex].g + 0.114 * palette[closestColorIndex].b;
                    resultCtx.fillStyle = luma > 128 ? 'black' : 'white';
                } else {
                    resultCtx.fillStyle = 'black';
                }
                
                resultCtx.fillText(number, x + cellWidth / 2, y + cellHeight / 2);
            }
        }

        let currentY = (height * scaleFactor) + palettePadding;
        resultCtx.font = `bold ${paletteTitleFontSize}px Arial`;
        resultCtx.fillStyle = 'black';
        resultCtx.textAlign = 'center';
        resultCtx.fillText('C√≥digo de Colores:', resultCanvas.width / 2, currentY);
        currentY += paletteTitleFontSize + (10 * scaleFactor);

        palette.forEach((color, index) => {
            const row = Math.floor(index / maxColorsPerRow);
            const col = index % maxColorsPerRow;
            const swatchX = palettePadding + col * itemWidth;
            const swatchY = currentY + row * (swatchSize + paletteTextFontSize + swatchGap);
            
            resultCtx.fillStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
            resultCtx.fillRect(swatchX, swatchY, swatchSize, swatchSize);
            resultCtx.strokeStyle = 'black';
            resultCtx.strokeRect(swatchX, swatchY, swatchSize, swatchSize);

            resultCtx.font = `bold ${paletteTextFontSize}px Arial`;
            resultCtx.fillStyle = 'black';
            resultCtx.textAlign = 'left';
            resultCtx.textBaseline = 'middle';
            resultCtx.fillText(`${index + 1}`, swatchX + swatchSize + (10 * scaleFactor), swatchY + swatchSize / 2);
        });
    }

    function displayPalette(palette) {
        paletteDiv.innerHTML = '';
        palette.forEach((color, index) => {
            const swatch = document.createElement('div'); swatch.className = 'color-swatch';
            const colorBox = document.createElement('div'); colorBox.className = 'color-box';
            colorBox.style.backgroundColor = `rgb(${color.r}, ${color.g}, ${color.b})`;
            const colorNumber = document.createElement('div'); colorNumber.className = 'color-number';
            colorNumber.textContent = `${index + 1}`;
            swatch.appendChild(colorBox); swatch.appendChild(colorNumber); paletteDiv.appendChild(swatch);
        });
    }

    function euclideanDistance(p1, p2) {
        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2) + Math.pow(p1[2] - p2[2], 2));
    }
});
</script>

</body>
</html>